# Important note
This is still kind of a "wizard of Oz" prototype, in that it does not programmatically generate the sonification. It uses pre-set audio files which I edited manually (in Reaper) to edit the volume over the course of the track.

This prototype just plays those audio clips (one per region) simultaeously and according to user input.

For how to go about editing the sounds programmatically, the implementation of "echo" should give some ideas.

These editions of these prototypes have not implemented the more complex UI features implemented in the coninuous sound version: playing individual sounds on their own, and selecting specific regions to play in the sonification.


# Dependencies
- Tone.js v15.3.5 ([here](https://tonejs.github.io/))
- KeyboardEvent API (built-in) (docs [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent))


# Sound map
See the file [`/documentation/scan_sound_map.json`](https://github.com/rachel-sedibridge/IMAGE-obj-sonification-prototypes/blob/main/documentation/scan_sound_map.json) for a preliminary mapping.

Includes potential semantic synonyms, and links to the original stock sound online.


# Segmented

## 1. Global variables
There are a lot of global variables and I'd like to get rid of some of them, but haven't had time yet.

The things that are meant to be configurable are separated as variables at the top of the file, to make changing them easier. These are:
- `TRIGGER_UP`, `TRIGGER_DOWN`, `TOGGLE_PLAY` (str): names (**as set in KeyboardEvents library**) of the keys that trigger moving up nd down within the sonification, and play/pause
- `NUM_SEGMENTS` (int): number of segments to divide the sonification into. **Defaults to 4**.
- `LOOPS` (boolean): whether each segment loops or just plays once. **Defaults to true**.

The URLs for the sound clips are also kept in variables at the top of the file. These are:
- the "start" and "end" voice clips (generated by a free [text-to-speech site](https://ttsmp3.com/)). 
- the edited files for each region (`[region]_real_tone`)
- the unedited stock sounds for each region (`[region]_eg_tone`)

Finally, there are a couple global variables that are referenced by several functions or across function calls, and using a global variable was simplest. These are:
- `regions_to_play`: dict of `{[region name]: [ [audio file url], [selected?] ]}`. The last (`selected?`) is not currently used in this prototype, because it's for one of the UI features not implemented yet. It has been left in order to make it easier to implement those later.
- `sgmt_tracker` (= 0): tracks which segment it's on. Starts at 0 ("start").
- `PLAYERS`: array of the `Tone.Player` objects for all the regions.

## 2. Setup / Initialization
On load, the script calls `initSounds()`. This goes through each entry in the `regions_to_play` dict, and if selected, creates a `Tone.Player` object for that region from the audio file URL. The `Player`'s name is set to the name of the region for easier debugging.

If `LOOPS` is true (if each segment should loop continuously), it syncs the `Player` to the `TransportTime` and sets it to start at time 0.  **I FORGET WHY OOPS COME BACK TO THIS**

It creates a `Tone.Channel` object (see [here](https://tonejs.github.io/docs/15.1.22/classes/Channel.html)) and connects the player to that, so that the "signal" goes through the Channel obj before going to output. This makes it easier to change the panning and volume on regions (`Player`s), or mute/solo them, independently of each other.

All these `Player` objects are added to an array, which is returned at the end. In practice, that array is assigned to a global variable, accessed by multiple functions during playback.

**NOTE**: Once selecting specific regions to put in the sonification is implemented, this function can be called every time that selection is changed (or every keydown after it's changed).

**Why not use `Tone.Players`?** Tone.js has an object (`Players`) that combines multiple `Player` objects, similarly to the array used here. I didn't use it, because it's mainly useful if you're doing the same thing to all those `Player`s. Since here, we're specifically going to be doing *different* things to every `Player` (region), it didn't really add anything and was confusing.

## 3. Playback
This uses the KeyboardEvent API to sync to user keybaord input, and Tone.js to play audio.

### 3.1. Segmentation, & moving b/w segments
The sonification is conceptually divided into 4 (by default, could be any number) segments, 1-indexed. Segment 0 (zero) is reserved for the "start" sound, and an additional segment at the end corresponds to the "end" sound. A global "segment tracker" (`sgmt_tracker`) tracks that index number.

The program sets a hard limit of that range: decrementing past 0 or incrementing past the "end" index does nothing.

The program starts on segment 0. The segment number is incremented between the user pressing the `TRIGGER_UP` or `TRIGGER_DOWN` keys and the actual playback. Thus, when the page first loads, pressing the `TOGGLE_PLAY` key will play the "start" sound, and pressing the `TRIGGER_UP` key will play the first segment. Because of the hard limit on indices, if the user presses `TRIGGER_DOWN` on page load (or when they've navigated back to the start), it will skip updating the `sgmt_tracker` and replay "start" sound.

Likewise, hitting `TRIGGER_UP` when you're already at the end just replays the "end" sound.

If it's set to loop, hitting `TRIGGER_UP` mid-sound will not jump straight to the next segement, but instead finish the current segment, seamlessly transition into the next, and then start looping that one. This doesn't happen for `TRIGGER_DOWN`; it just jumps immediately to the start of the previous segment. This was not intentional and is probably a consequence of how the playback is scheduled, but it seemed cool so I left it.

### 3.2. Handling user (keyboard) input
There is an `EventListener` for "keydown" events of any kind, which immediately calls the function `handleDown()`. *NOTE: there is the outline to easily implement a response when the user lifts the key, but it's not currently used. Since we only care about individual keypresses here, keydown and keyup might as well be the same event.*

The function `handleDown()` ignores all but the initial keydown (i.e. keydown events that keep being sent when a user holds down a key). It explicitly handles the three important keys (`TRIGGER_UP`, `TRIGGER_DOWN`, and `TOGGLE_PLAY`, defined above), and lets everything else just run through and return without doing anything.

On `TRIGGER_UP` and `TRIGGER_DOWN`, it calls the `sonify()` helper function with a flag saying which one it was (boolean `movingUp`). On `TOGGLE_PLAY`, it either stops the sounds currently playing, or calls the same `sonify()` helper to resume. In the latter case, it throws in an optional flag (`repeating = true`) to indicate that this is replaying the current segment. See why below.

### 3.3. NOTE - pausing playback
As described in the Tone.js additional documentation (`documentation/tonejs.md`), you cannot simply "stop" or pause playback of something that's already scheduled into the `Transport`. This implementation works by setting all the `Players` (for each region) to play on a certain time interval. For this reason, the only way I could figure out to stop playback once it started was to go through and mute every `Player` in the array. This also means it has to check and unmute if necessary before starting playback again. It's a hacky workaround, so if you come up with something better please go ahead and change it lol.

### 3.4 Playing a segment (`sonify()` helper)
First, "move" the script to the correct segment by incrementing or decrementing the `sgmt_tracker` (segment tracker). That flag that says whether user moved up or down (bool `movingUp`) determines which. If the optional `repeating` flag is set, skip this step. As described in 3.1, if this operation would take it outside the permitted range, also skip this step.

Depending on the value of `sgmt_tracker` after this, it either plays the start sound or end sound, or calls another helper function (`playAllRegions()`) to play the appropriate segment of the sonification (logic separated for legibility).

In short, that helper function calculates segment duration and start time within the audio tracks ("offset"), sets the `Player` for each region to play (or loop) over that time, and starts the playback.

In more detail: 
1. Since the segments are of equal length, segment len = length of an audio track / number of segments.
2. The offset (how far into the tracks to pick up playing) is 0 for segment 1, [segment len] for segment 2, 2 * [segment len] for segment 3, ...etc. Thus, offset = `(sgmt_tracker - 1) * [segment len]`.
3. If the segments should loop, it sets `loopStart = offset` and `loopEnd = offset + [segment len]` for each `Player`. Otherwise, use the optional parameters to `Player.start()` to have it start playing at `TransportTime = 0` but from `offset = offset` within the audio track, and for `duration = segment len`. 
    - In the latter case, also set `Transport` to stop after that duration. This maps `Transport.state == 'started'` to whether audio is still playing for the user, which the handler of `TOGGLE_PLAY` keypress needs to know. 
4. It then starts the playback from `TransportTime = 0` with `Tone.getTransport().start()` (`getTransport` not `Transport`: using v15 syntax).


# Continuous Sound
**IMPORTANT: This prototype is not complete.** Specifically, the backwards playback doesn't pick up from the right time. The file is also generally messier and still has some debug stuff in it: I'll clean that up at some point, probably (sorry).

The implementation of this prototype is broadly very similar to the implementation of the segmented prototype detailed above, so this section will just go over what's different.

## Unfinished - backwards playback
With a Tone.js `Player` object, calling `Player.reverse()` reverses the associated audio track and *does not* change the `TransportTime`. Effect best illustrated through example: say you've paused 3 seconds into a 9 second recording, and now you want to play backwards to the start. You'd expect to pick up from that same **point in the track**. But under the current implementation, you'd pick up from **3 seconds into the *reversed* track**, which is **6 seconds into the regular (un-reversed) track**. 

**The obvious way to fix this is to manually set the time** (either using the `offset` parameter in `Tone.Player.start()`, or the `TransportTime` parameter in `Tone.getTransport().start()`). I was partway through fixing this before I abandoned it in favour of the (more easily-implemented) segmented idea.

## Handling user (keyboard) input
There are two EventListeners: one for "keydown" and one for "keyup" events, because this version should start playback on keydown and stop it on keyup.

### Keydown
On a key other than `TRIGGER_UP` or `TRIGGER_DOWN`, exit early (ignore). On "repeat" keys call `Tone.getTransport().stop()` if the `TransportTime` is greater than or equal to the duration of the sonification (**NOTE: I don't think this is effective**), else return early (ignore). Play


# User Interface
